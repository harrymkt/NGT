/*
Sound Pool(An alternative way to manage sounds.)
*/
array<sound_pool@> g_sound_pools(0);
class sound_pool {
	private array<sound@> sounds;
	bool in_window;
	long free_time;
	timer free_timer;
	protected bool pool_thread_active;
	vector@ listener;
	private array<audio_effect> effects;
	protected thread@ pool_thread;
	long max_sounds;
	private bool use_hrtf;
	private uint64 id;
	sound_pool() {
		this.reset();
		g_sound_pools.insert_last(this);
		this.id=g_sound_pools.length()-1;
	}
	~sound_pool() {
		this.reset();
		g_sound_pools.remove_at(this.id);
	}
	void reset() {
		sounds.resize(0);
		in_window=false;
		free_time=3000;
		free_timer.restart();
		pool_thread_active=false;
		@listener=null;
		effects.resize(0);
		@pool_thread=null;
		max_sounds=100;
		use_hrtf=true;
	}
};
shared class audio_effect {
	string type;
	audio_effect(const string&in type) {
		this.type = type;
	}
	audio_effect() {
	}
	protected bool in_range(float value, float min, float max) {
		bool ir = true;
		if(value>max || value<min) ir = false;
		return ir;
	}
	bool is_safe(sound@handle) {
		if(@handle == null) return false;
		if(!handle.active) return false;
		return true;
	}
	protected bool attach(sound@handle) {
		if(!this.is_safe(handle)) return false;
		handle.set_fx(this.type);
		return this.configure_effect(handle);
	}
	protected bool detach(sound@handle) {
		if(!this.is_safe(handle)) return false;
		handle.delete_fx(this.type);
		return true;
	}
	bool configure_effect(sound@handle) {
		return false;
	}
};