/*
Sound Pool(An alternative way to manage sounds.)
*/
array<sound_pool@> g_sound_pools(0);
enum sp_result {
	SP_SUCCESS = 0,
	SP_ALL_SOUNDS_BUSY = -1,
	SP_INVALID_ARGS = -2
};
class sound_pool {
	private array<sound@> sounds;
	bool in_window;
	long free_time;
	timer free_timer;
	protected bool pool_thread_active;
	vector@ listener = null;
	private array<audio_effect> effects;
	protected thread@ pool_thread;
	long max_sounds;
	private bool use_hrtf;
	private uint64 id;
	sp_result last_error;
	sound_pool() {
		this.reset();
		g_sound_pools.insert_last(this);
		this.id=g_sound_pools.length()-1;
	}
	~sound_pool() {
		this.reset();
		g_sound_pools.remove_at(this.id);
	}
	void reset() {
		last_error=SP_SUCCESS;
		in_window = false;
		free_time = 3000;
		free_timer.restart();
		pool_thread_active = false;
		@listener = null;
		effects.resize(0);
		@pool_thread = null;
		max_sounds = 100;
		sounds.resize(max_sounds);
		use_hrtf = true;
	}
	protected uint get_free_sound_id() {
		last_error=SP_SUCCESS;
		uint it;
		bool found = false;
		for (it = 0; it < sounds.length(); it++) {
			if (sounds[it] is null) {
				found = true;
				break;
			}
			else if(sounds[it].active && !sounds[it].playing) {
				sounds[it].close();
				found = true;
				break;
			}
			else if (!sounds[it].active) {
				found = true;
				break;
			}
		}
		if (found)return it;
		last_error = SP_ALL_SOUNDS_BUSY;
		return last_error;
	}
	int play(const string &in filename, float listener_x = 0, float listener_y = 0, float listener_z = 0, float source_x = 0, float source_y = 0, float source_z = 0, double rotation = 0, int left_range = 0, int right_range = 0, int backward_range = 0, int forward_range = 0, int upper_range = 0, int lower_range = 0, bool loop = false, bool wait = false, double offset = 0, float start_pan = 0, float start_volume = 0, float start_pitch = 100.0f, bool memory = false) {
		last_error=SP_SUCCESS;
		if(loop && wait){
			last_error = SP_INVALID_ARGS;
			return last_error;
		}
		
	}
};
shared class audio_effect {
	string type;
	audio_effect(const string&in type) {
		this.type = type;
	}
	audio_effect() {
	}
	protected bool in_range(float value, float min, float max) {
		bool ir = true;
		if(value>max || value<min) ir = false;
		return ir;
	}
	bool is_safe(sound@handle) {
		if(@handle == null) return false;
		if(!handle.active) return false;
		return true;
	}
	protected bool attach(sound@handle) {
		if(!this.is_safe(handle)) return false;
		handle.set_fx(this.type);
		return this.configure_effect(handle);
	}
	protected bool detach(sound@handle) {
		if(!this.is_safe(handle)) return false;
		handle.delete_fx(this.type);
		return true;
	}
	bool configure_effect(sound@handle) {
		return false;
	}
};
